光照
=============
本章将着重介绍OpenGL中光照的实现。

颜色
----------------
颜色数字化由红色(Red)、绿色(Green)和蓝色(Blue)三个分量组成，它们通常被缩写为RGB。仅仅使用这三个值就可以组合出任意一种颜色。

现实生活中看到某一物体的颜色并不是这个物体真正的颜色，而是它所反射的(Reflected)颜色。换句话说，哪些不能被物体所吸收(Absorb)的颜色(被拒绝的颜色)就是能够感知到的物体的颜色。

![物体反射颜色原理图](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/basic_color.jpg)

这些颜色反射的定律被直接地运用在图形领域。当把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色(也就是所感知到的颜色)。

```
		glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
		glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
		glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f)
```

通过上例可以看出物体的颜色**吸收**了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。

基础光照
----------------
现实世界的光照是极其复杂的，并且会受到诸多因素的影响。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是机遇对光的物理特性的理解。其中一个模型被称为**冯氏光照模型(Phong Lighting Model)**。冯氏光照模型的主要结构由3个分量组成:环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。

![冯氏光照模型](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/phong.jpg)

* 环境光照(Ambient Lighting):即使在黑暗的情况下，世界上通常也仍然有一些光照，所有物体几乎永远不会是完全黑暗的。为了模拟这个，会使用一个环境光照常量，它永远会给物体一些颜色。
* 漫反射光照(Diffuse Lighting):模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。
* 镜面光照(Specular Lighting):模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

**环境光照**

光通常都不是来自于同一个光源，而是来自于周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做**全局照明(Global lilumination)**算法，但是这种算法既开销高昂又极其复杂。

这里将会先使用一个简化的全局照明模型，即环境光照。使用一个很小的常量(光照)颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。

**漫反射光照**

环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。

![漫反射光照](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/diffuse.jpg)

上图中图左上方有一个光源，它所发出的光线落在物体的一个片段上。需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化(更亮)。为了测量光线的片段的角度，使用一个叫做**法向量(Normal Vector)**的东西，它是垂直于片段表面的一个向量(以黄色箭头表示)。这两个向量之间的角度很容易就能够通过点乘计算出来。

>注意，为了(只)得到两个向量夹角的余弦值，使用的都是单位向量(长度为1的向量),所以需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。

点乘返回一个标量，可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。

计算漫反射光照需要:

* 发向量:一个垂直于顶点表面的向量。
* 定向的光线:作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，需要光的位置向量和片段的位置向量。

**法向量**

法向量是一个垂直于顶点表面的(单位)向量。由于顶点本身并没有表面(它只是空间中一个独立的点)，利用它周围的顶点来计算出这个顶点的表面。

**计算漫反射光照**

计算光线向量与法向量之间夹角的计算向量是在世界坐标系中进行计算，把所有的向量都转变到世界坐标系，然后进行计算。

>当计算光照时通常不关心一个向量的模长或它的位置，只关心它们的方向。所以，几乎所有的计算都适用单位向量完成，因为这简化了大部分的计算。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保存它们是真正地单位向量。注意二者之间的夹角可能大于90，因此要注意不能够把光照向量变成负数。

**最后一件事**

现在已经把法向量丛顶点着色器传递到片段着色器。可是，目前片段着色器里的计算都是在世界空间坐标中进行的。所以，是不是应该把法向量也转换为世界空间坐标？基本正确，但是这不是简单地把它乘以一个模型矩阵就能搞定的。

首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标(顶点位置中的w分量)。这意味着，位移不应该影响到发向量。因此，如果打算把法向量乘以一个模型矩阵，就要从矩阵中移除位移部分，只选用模型矩阵左上角3✖️3的矩阵。对于法向量，只希望对它实施缩放和旋转变换。

其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面。因此，不能用这样的模型矩阵来变换法向量。如下图所示：

![法向量图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/normal.jpg)

每当应用一个不等比缩放时，法向量就不会再垂直于对应的表面，这样光照就会被破坏。

修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为**法线矩阵(Normal Matrix)**，它使用一些线性代数的操作来移除对法向量错误缩放的影响。法线矩阵被定义为[模型矩阵左上角的逆矩阵的转置矩阵]。大部分的资源都会将法线矩阵定义为应用到模型--观察矩阵(model-view Matrix)上的操作，但是由于只在世界空间中进行操作(不是在观察空间)，只使用模型矩阵。

在顶点着色器中，可以使用`inverse`和`transpose`函数生成这个法线矩阵，这两个函数对所有类型矩阵都有效。

			`Normal = mat3(transpose(inverse(model))) * aNormal`
			
在漫反射光照部分，光照表现并没有问题，这是因为没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果你进行了不等比缩放，使用法线矩阵去乘以法向量就是必不可少的。

>即使是对于着色器来说，逆矩阵也是一个开销比较大的运算。因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。对于一个对效率有要求的应用来说，在绘制之前最好用CPU计算出法线矩阵，然后通过`uniform`把值传递给着色器。

**镜面光照**

和漫反射光照一样，镜面光照也是依据光的方向向量和物体的法向量来决定，但是它也依赖于观察方向。镜面光照是基于光的反射特性。如果想象物体表面像一面镜子一样，那么，无论从哪里去看那个表面所反射的光，镜面光照都会达到最大化。例如下图所示:

![镜面光照](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/specular.jpg)

通过反射法向量周围光的方向来计算反射向量。然后计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，会看到一个高光。

观察向量是镜面光照附加的一个变量，可以使用观察这世界空间位置和片段的位置来计算它。之后，计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。

>选择在世界空间进行光照计算，但是大多数人趋向于在观察空间进行光照计算。在观察空间计算的好处是，观察者的位置总是(0,0,0)，所以这样你直接就获得了观察者位置。可是发现在世界空间中计算光照更加符合直觉。

为了得到观察者的世界空间坐标，简单地使用摄像机对象的位置坐标代替。已经获得所有需要的变量，可以计算高光强度。首先，定义一个镜面强度(Specular intensity)变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。

* 先计算反射向量 `vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm);`
* 然后计算镜面分量 `float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);`

先计算视线方向与反射方向的点乘(并确保它不是负值)，然后取它的32次幂。这个32是高光的**反光度(Shininess)**。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。如下图所示:

![高光视觉效果](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/shininess.jpg)

>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以(开销大的)光照计算频率会更低。顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。
>
>![高光视觉效果](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/gouraud.jpg)
>
>在顶点着色器中实现的冯氏光照模型叫做**Gouraud着色(Gouraud Shading)**，而不是**冯氏着色(Phong Shading)**.


