光照
=============
本章将着重介绍OpenGL中光照的实现。

颜色
----------------
颜色数字化由红色(Red)、绿色(Green)和蓝色(Blue)三个分量组成，它们通常被缩写为RGB。仅仅使用这三个值就可以组合出任意一种颜色。

现实生活中看到某一物体的颜色并不是这个物体真正的颜色，而是它所反射的(Reflected)颜色。换句话说，哪些不能被物体所吸收(Absorb)的颜色(被拒绝的颜色)就是能够感知到的物体的颜色。

![物体反射颜色原理图](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/basic_color.jpg)

这些颜色反射的定律被直接地运用在图形领域。当把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色(也就是所感知到的颜色)。

```
		glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
		glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
		glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f)
```

通过上例可以看出物体的颜色**吸收**了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。

基础光照
----------------
现实世界的光照是极其复杂的，并且会受到诸多因素的影响。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是机遇对光的物理特性的理解。其中一个模型被称为**冯氏光照模型(Phong Lighting Model)**。冯氏光照模型的主要结构由3个分量组成:环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。

![冯氏光照模型](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/phong.jpg)

* 环境光照(Ambient Lighting):即使在黑暗的情况下，世界上通常也仍然有一些光照，所有物体几乎永远不会是完全黑暗的。为了模拟这个，会使用一个环境光照常量，它永远会给物体一些颜色。
* 漫反射光照(Diffuse Lighting):模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。
* 镜面光照(Specular Lighting):模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

**环境光照**

光通常都不是来自于同一个光源，而是来自于周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做**全局照明(Global lilumination)**算法，但是这种算法既开销高昂又极其复杂。

这里将会先使用一个简化的全局照明模型，即环境光照。使用一个很小的常量(光照)颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。

**漫反射光照**

环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。

![漫反射光照](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/diffuse.jpg)

上图中图左上方有一个光源，它所发出的光线落在物体的一个片段上。需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化(更亮)。为了测量光线的片段的角度，使用一个叫做**法向量(Normal Vector)**的东西，它是垂直于片段表面的一个向量(以黄色箭头表示)。这两个向量之间的角度很容易就能够通过点乘计算出来。

>注意，为了(只)得到两个向量夹角的余弦值，使用的都是单位向量(长度为1的向量),所以需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。

点乘返回一个标量，可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。

计算漫反射光照需要:

* 发向量:一个垂直于顶点表面的向量。
* 定向的光线:作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，需要光的位置向量和片段的位置向量。

**法向量**

法向量是一个垂直于顶点表面的(单位)向量。由于顶点本身并没有表面(它只是空间中一个独立的点)，利用它周围的顶点来计算出这个顶点的表面。

**计算漫反射光照**

计算光线向量与法向量之间夹角的计算向量是在世界坐标系中进行计算，把所有的向量都转变到世界坐标系，然后进行计算。

>当计算光照时通常不关心一个向量的模长或它的位置，只关心它们的方向。所以，几乎所有的计算都适用单位向量完成，因为这简化了大部分的计算。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保存它们是真正地单位向量。注意二者之间的夹角可能大于90，因此要注意不能够把光照向量变成负数。

**最后一件事**

现在已经把法向量丛顶点着色器传递到片段着色器。可是，目前片段着色器里的计算都是在世界空间坐标中进行的。所以，是不是应该把法向量也转换为世界空间坐标？基本正确，但是这不是简单地把它乘以一个模型矩阵就能搞定的。

首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标(顶点位置中的w分量)。这意味着，位移不应该影响到发向量。因此，如果打算把法向量乘以一个模型矩阵，就要从矩阵中移除位移部分，只选用模型矩阵左上角3✖️3的矩阵。对于法向量，只希望对它实施缩放和旋转变换。

其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面。因此，不能用这样的模型矩阵来变换法向量。如下图所示：

![法向量图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/normal.jpg)

每当应用一个不等比缩放时，法向量就不会再垂直于对应的表面，这样光照就会被破坏。

修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为**法线矩阵(Normal Matrix)**，它使用一些线性代数的操作来移除对法向量错误缩放的影响。法线矩阵被定义为[模型矩阵左上角的逆矩阵的转置矩阵]。大部分的资源都会将法线矩阵定义为应用到模型--观察矩阵(model-view Matrix)上的操作，但是由于只在世界空间中进行操作(不是在观察空间)，只使用模型矩阵。

在顶点着色器中，可以使用`inverse`和`transpose`函数生成这个法线矩阵，这两个函数对所有类型矩阵都有效。

			`Normal = mat3(transpose(inverse(model))) * aNormal`
			
在漫反射光照部分，光照表现并没有问题，这是因为没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果你进行了不等比缩放，使用法线矩阵去乘以法向量就是必不可少的。

>即使是对于着色器来说，逆矩阵也是一个开销比较大的运算。因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。对于一个对效率有要求的应用来说，在绘制之前最好用CPU计算出法线矩阵，然后通过`uniform`把值传递给着色器。

**镜面光照**

和漫反射光照一样，镜面光照也是依据光的方向向量和物体的法向量来决定，但是它也依赖于观察方向。镜面光照是基于光的反射特性。如果想象物体表面像一面镜子一样，那么，无论从哪里去看那个表面所反射的光，镜面光照都会达到最大化。例如下图所示:

![镜面光照](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/specular.jpg)

通过反射法向量周围光的方向来计算反射向量。然后计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，会看到一个高光。

观察向量是镜面光照附加的一个变量，可以使用观察这世界空间位置和片段的位置来计算它。之后，计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。

>选择在世界空间进行光照计算，但是大多数人趋向于在观察空间进行光照计算。在观察空间计算的好处是，观察者的位置总是(0,0,0)，所以这样你直接就获得了观察者位置。可是发现在世界空间中计算光照更加符合直觉。

为了得到观察者的世界空间坐标，简单地使用摄像机对象的位置坐标代替。已经获得所有需要的变量，可以计算高光强度。首先，定义一个镜面强度(Specular intensity)变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。

* 先计算反射向量 `vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm);`
* 然后计算镜面分量 `float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);`

先计算视线方向与反射方向的点乘(并确保它不是负值)，然后取它的32次幂。这个32是高光的**反光度(Shininess)**。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。如下图所示:

![高光视觉效果](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/shininess.jpg)

>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以(开销大的)光照计算频率会更低。顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。
>
>![高光视觉效果](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/gouraud.jpg)
>
>在顶点着色器中实现的冯氏光照模型叫做**Gouraud着色(Gouraud Shading)**，而不是**冯氏着色(Phong Shading)**.

材质
--------------------
想要在OpenGL中模拟多种类型的物体，必须为每个物体分别定义一个**材质(Material)**属性。当描述一个物体的时候，用这三个分量来定义一个材质颜色(Material Color):环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)。通过为每个分量指定一个颜色，就能够对物体的颜色输出有精确的控制。再添加一个反光度(Shininess)这个分量，就构成了材质的所有属性。

					`#version 330 core
					 struct Material {
					 	vec3 ambient;
					 	vec3 diffuse;
					 	vec3 specular;
					 	float shininess;
					 };
					 
					 uniform Material material;`
					 
通过上结构体可以看出，为冯氏光照模型中每一个分量都定义一个颜色向量。`ambient`材质向量定义了在环境光照下这个物体反射的是什么颜色，通常这是和物体颜色相同的颜色。`diffuse`材质向量定义了在漫反射光照下物体的颜色。`specular`材质向量设置的是镜面光照对物体的颜色影响(或者甚至可能反射一个物体特定的镜面高光颜色)。最后，`shininess`影响镜面高光的散射/半径。通过这个材质系统就可以模拟现实世界中的材质。

**光的属性**

光源对环境光、漫反射和镜面光照分量也有具有着不同的强度。前面通过使用一个强度值来改变环境光和镜面光照强度的方式来解决问题，但这次使用为每个光照分量都指定一个强度分量。

					`struct Light {
					 	vec3 position;
					 	
					 	vec3 ambient;
					 	vec3 diffuse;
					 	vec3 specular;
					 };
					 
					 
					 uniform Light light;`

一个光源对它的`ambient`、`diffuse`和`specular`光照有着不同的强度。环境光照通常会设置一个比较低的强度。光源的漫反射分量通常为光所具有的颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为`vec3(1.0)`，以最大强度发光。

光照贴图
--------------------
让每个物体都拥有自己独特的材质从而对光照做出不同的反应的方法。这样子能够很容易在一个光照的场景中给每个物体一个独特的外观，但是这仍然不能对一个物体的视觉输出提供足够多的灵活性。现实世界中的物体通常并不只包含有一个材质，而是由多种材质所组成。前面讲的是最简单的模型，所以需要拓展之前的系统，引入漫反射和镜面光贴图(Map)。这允许对物体的漫反射分量和镜面光分量有着更精确的控制。

**漫反射贴图**

通过某种方式对物体的每个片段单独设置漫反射颜色，能够根据片段在物体上的位置来获取颜色值。这就是前面讲的纹理系统。仅仅是在光照场景中，它通常叫做一个漫反射贴图(Diffuse Map)，它是一个表现了物体所有的漫反射颜色的纹理图像。

在着色器中使用漫反射贴图的方法和纹理是完全一样的，将纹理存储为`Material`结构体中的一个`sampler2D`.将之前定义的`vec3`漫反射颜色向量替换为漫反射贴图。

>注意`sampler2D`是所谓的**不透明类型(Opaque Type)**,也就是说不能将它实例化，只能通过`uniform`来定义它。如果使用除`uniform`以外的方法实例化这个结构体，`GLSL`会抛出一些奇怪的错误。这同样也适用于任何封装了不透明类型的结构体。

使用漫反射贴图时，也应当移除环境材质颜色向量，因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以不需要讲它们分开储存。

				`struct Material {
				 	sampler2D diffuse;
				 	vec3 		specular;
				 	float		shininess;
				 };
				 
				 in vec2 TexCoords;`

使用漫反射纹理来进一步提高效果，顶点数据中包含了顶点位置、法向量和立方体顶点处的纹理坐标，更新顶点着色器来以顶点属性的形式接受纹理坐标，并将它们传递到片段着色器中。

**镜面光贴图**

通过使用漫反射贴图可以进一步提高显示效果，但是对于镜面高光的处理并不理想。为了能够提高显示效果，同样可以使用一个专门用于镜面高光的纹理贴图。这就意味着需要生成一个黑白纹理，来定义物体每部分的镜面光强度。

镜面高光的强度可以通过图像每个像素的亮度来获取。镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量`vec3(0.0)`，灰色代表颜色向量`vec3(0.5)`。在片段着色器中，会取样对应的颜色值并将它乘以光源的镜面强度。

>从实际角度来说，木头其实也有镜面高光，尽管它的反光度(Shininess)很小(更多的光被散射)，影响也比较小，但是为了教学目的，可以假设木头不会对镜面光有任何反应。

**采样镜面光贴图**

镜面光贴图和其它的纹理非常类似，所以代码也和漫反射贴图的代码很类似。因此，更新物体的材质属性如下：

					`struct Material {
					 	sampler2D diffuse;
					 	sampler2D specular;
					 	float		shininess;
					 };`
					 
从而计算冯氏光照模型的各个分量，其代码如下：

			`vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));
			 vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, Texcoords));
			 vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
			 FragColor = vec4(ambient + diffuse + specular, 1.0);`
					 
通过使用镜面光贴图可以对物体设置大量的细节。镜面光贴图能够在漫反射贴图给予更高一层的控制。

>也可以在镜面光贴图中使用真正的颜色，不仅设置每个片段的镜面光强度，还设置了镜面高光的颜色。从实现角度来说，镜面高光的颜色大部分(甚至全部)都是由光源本身所决定的，所以这样并不能生成非常真实的视觉效果。

通过使用漫反射和镜面光贴图，可以给相对简单的物体添加大量的细节。甚至可以使用**法线/凹凸贴图**(Normal/BumpMap)或者**反射贴图**(Reflection Map)给物体添加更多的细节。

投光物
--------------------
将光**投射(Cast)**到物体的光源叫做**投光物(Light Caster)**。首先会讨论定向光(Directional Light)，接下来是点光源(Point Light),最后将讨论聚光(Spotlight)。

**平行光**

当一个光源处于很远的地方时，来自光源的每条光线就会近似于相互平行。不论物体和或者观察者的位置，看起来好像所有的光都来自于同一个方向。当使用一个假设光源处于无限远处的模型时，它就被称为**定向光**，因为它的所有光线都有着相同的方向，它与光源的位置是没有关心的。

定向光非常好的一个例子就是太阳，所有来自太阳的所有光线将被模拟为平行光线。

![平行光](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/Parallel_light.jpg)

因为所有的光线都是平行的，所以物体与光源的相对位置是不重要的，因为对场景中每一个物体光的方向都是一致的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。

定一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次将直接使用光的`direction`向量而不是通过`direction`来计算`lightDir`向量。

	`struct Light {
	 // vec3 position;
	 vec3 direction;
	 
	 vec3 ambient;
	 vec3 diffuse;
	 vec3 specular;
	}
	
	...
	void main() {
		vec3 lightDir = normalize(-light.direction);
		...
	}`

注意首先对`light.direction`向量取反。目前使用的光照计算需要一个从片段至光源的光线方向，但更需要定义定向光为一个从光源出发的全局方向。所以需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量。记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。

>一直将光的位置和位置向量定义为`vec3`，但一些人会喜欢将所有的向量都定义为`vec4`。但将位置向量定义为一个`vec4`时，很重要的一点是要将w分量设置为1.0，这样变换和投影才能正确应用。然而，当定义一个方向向量为`vec4`的时候，不想让位移有任何的效果(因为它仅仅代表的是方向)，所以将w分量设置为0.0。

**点光源**

定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外也需要一些分散在场景中的**点光源(Point Light)**.点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。

![点光源](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/point.jpg)

在之前的教程中，一直都在使用一个(简化的)点光源。在给定位置有一个光源，它会从它的光源位置开始朝着所有方向散射光线。然而，定义的光源模拟的是永远不会衰减的光线，这看起来像是光源亮度非常的强。在大部分的3D模拟中，都希望模拟的光源仅照亮光源附近的区域而不是整个场景。

**衰减**

随着光线传播距离的增长逐渐消减光的强度通常叫做**衰减(Attenuation)**。随距离减少光强度的一种方式是使用一个线性方程。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线形方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢。因此，光源的计算公式如下:

![点光源的距离衰减图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/point_delance.jpg)

在这里`d`代表片段距离光源的距离。接下来为了计算衰减值，定义3个(可配置的)项:常数项Kc、一次项Kl和二次项Kq。

* 常数项通常保持1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度。
* 一次项会与距离值相乘，以线性的方式减少强度。
* 二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项再距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。

由于二次项的存在，光线会在大部分时候以线性的方式衰减，直到距离变得最够大，让二次项超过一次项，光的强度会以更快的速度下降。这样的结果就是，光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。下面这张图显示了在100的距离内衰减的效果:

![100距离内光线衰减图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/pointdistance.jpg)

可以看到光在近距离的时候有着最高的强度，但随着距离增长，它的强度明显减弱，并缓慢地距离大约100的时候强度接近0。

**选择正确的值**

正确地设置点光源的三个值取决于很多因素：环境、希望光覆盖的距离、光的类型等。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个(大概)真实的，覆盖特定半径(距离)的光源时，这些项可能取的一些值。第一列制定的是在给定三项时光所能覆盖的距离。这些值是大多数光源很好的起始点。

![点光源的三项值设定](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/distance.jpg)

可以看到，常数项Kc在所有的情况下都是1.0。一次项Kl为了覆盖更远的距离通常都很小，二次项Kq甚至更小。

**实现衰减**

为了实现衰减，在片段着色器中还需要是三个额外的值:也就是公式中的常数项、一次项和二次项。它们最好存储在之前定义的`Light`结构体中。

		 struct Light {
		 	vec3 position;
		 	
		 	vec3 ambient;
		 	vec3 diffuse;
		 	vec3 specular;
		 	
		 	float constant;
		 	float linear;
		 	float quadratic;
		 }
		 
>可以将环境光分量保持不变，让环境光照不会随着距离减少，但是如果使用多于一个的光源，所有的环境光分量将会开始叠加，所以这种情况下也可以减少环境光照。

**聚光**

最后一种类型的光是**聚光(Spotlight)**。聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。

OpenGL中聚光是用一个世界空间位置、一个方向和一个**切光角(Cutoff Angle)**来表示的，切光角指定了聚光的半径。对于每个片段，会计算片段是否位于聚光的切光方向之间，如果是的话，就会相应地照亮片段。如下图所示,聚光的工作原理:

![聚光的图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/spotlight.jpg)

* `LightDir`:从片段指向光源的向量。
* `SpotDir`:聚光所指向的方向。
* `Phi`:指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。
* `Theta`:`LightDir`向量和`SpotDir`向量之间的夹角。在聚光内部的话`Phi`的值应该比`Theta`值小。

采用聚光时候，注意如果直接使用聚光的计算会产生很生硬的一个照亮光圈，给我们的感觉不真实，所以采用平滑/软化边缘。

为了看起来能够有边缘平滑的聚光，需要模拟聚光有一个内圆锥(Inner Cone)和外圆锥(Outer Cone)。可以将内圆锥设置为上一部分中的那个圆锥，但也需要一个外圆锥，来让光从内圆锥逐渐减暗，直到外圆锥的边界。

为了创建一个外圆锥，只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量(等于它的半径)的夹角。然后，如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值。如果片段在内圆锥之内，它的强度就是1.0，如果在外圆锥之外强度就是0.0。

可以用这个公式来计算这个值:

![聚光强度的计算公式](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter2/calc_light.jpg)

这个只是根据内外余弦值之间根据θ插值。在OpenGL中可以使用clamp函数来约束参数值在0.0到1.0之间。

**多光源**

GLSL中的函数和C函数很相似，它有一个函数名、一个返回值类型。如果函数不是在main函数之前声明的，就必须在代码文件顶部声明一个原型。

>我们也可以定义一个大的结构体（而不是为每种类型的光源定义不同的结构体），包含所有不同种光照类型所需的变量，并将这个结构体用到所有的函数中，只需要忽略用不到的变量就行了。然而，我个人觉得当前的方法会更直观一点，不仅能够节省一些代码，而且由于不是所有光照类型都需要所有的变量，这样也能节省一些内存。


词汇表
----------------------
* 颜色向量(Color Vector):一个通过红绿蓝(RGB)分量的组合描绘大部分真实颜色的向量。一个物体的颜色实际上是该物体所不能吸收的反射颜色分量。
* 冯氏光照模型(Phong Lighting Model):一个通过计算环境光、漫反射和镜面光分量的值来估计真是光照的模型。
* 环境光照(Ambient Lighting):通过给每个没有被光照的物体很小的亮度，使其不是完全黑暗的，从而对全局光照进行估计。
* 漫反射着色(Diffuse Shading):一个顶点/片段与光线方向越接近，光照会越强。使用了法向量来计算角度。
* 法向量(Normal Vector):一个垂直于平面的单位向量。
* 法线矩阵(Normal Matrix):一个3✖️3矩阵，或者说是没有平移的模型(或者模型--观察)矩阵。它也被以某种方式修改(逆转置)，从而在应用非统一缩放时，保持法向量朝向正确的方向。否则法向量会在使用非统一缩放时被扭曲。
* 镜面光照(Specular Lighting):当观察者视线靠近光源在表面的反射线时会显示的镜面高光。镜面光照是由观察者的方向，光源的方向和设定高光分散量的反光度值三个量共同决定的。
* 冯氏着色(Phong Shading):冯氏光照模型应用在片段着色器。
* Gouraud着色(Gouraud shading):冯氏光照模型应用在顶点着色器上。在使用很少数量的顶点时会产生明显的瑕疵。会得到效率提升但是损失了视觉质量。
* GLSL结构体(GLSL struct):一个类似于C的结构体，用于着色器变量的容器。大部分时间用来管理输入/输出/uniform。
* 材质(Material):一个物体反射的环境光、漫反射和镜面光颜色。这些东西设定了物体所拥有的颜色。
* 光照属性(Light(properites)):一个光的环境光、漫反射和镜面光的强度。可以使用任何颜色值，对每一个冯氏分量(Phong Component)定义光源发出的颜色/强度。
* 漫反射贴图(Diffuse Map):一个设定了每个片段中漫反射颜色的纹理图片。
* 镜面光贴图(Specular Map):一个设定了每一个片段的镜面光强度/颜色的纹理贴图。尽在物体的特定区域显示镜面高光。
* 定向光(Directional Light):只有一个方向的光源。它被建模为不管距离有多长所有光束都是平行而且其方向向量在整个场景中保持不变。
* 点光源(Point Light):一个场景中有位置的，光线逐渐衰减的光源。
* 衰减(Attenuation):光随着距离减少强度的过程，通常使用在点光源和聚光下。
* 聚光(Spotlight):一个被定义为在某一个方向上的锥形的光源。
* 手电筒(Flashlight):一个摆放在观察者视角的聚光。
* GLSL uniform数组(GLSL Uniform Array):一个uniform值数组。它的工作原理和C语言数组大致一样，只是不能动态分配内存。