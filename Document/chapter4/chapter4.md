高级OpenGL
========================
本章节主要讲述OpenGL的高级技术。

深度测试
-----------------------------
在渲染箱子时，运用了深度缓冲(Depth Buffer)来防止被阻挡的面渲染到其它面的前面。在本小节中将更加深入地探讨这些储存在深度缓冲(或z缓冲(z-buffer))中的深度值(Depth Value)，以及它们是如何确定一个片段是处于其他片段后方的。

深度缓冲就像颜色缓冲(Color Buffer)(储存所有得片段颜色:视觉输出)一样，在每个片段中储存了信息，并且(通常)和颜色缓冲区有着一样的宽高。深度缓冲区是由窗口系统自动创建的，它会以16、24或32位float的形式存储他的深度值。在大部分的系统中，深度缓冲的精度都是24位的。

当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。

深度缓冲是在片段着色器运行之后(以及模版测试(Stencil Testing)运行之后)在屏幕空间中运行的。屏幕空间坐标与OpenGL的`glViewport`所定义的视口密切相关，并且可以直接使用GLSL内建变量`gl_FragCoord`从片段着色器中直接访问。`gl_FragCoord`的`x`和`y`分量代表了片段的屏幕空间坐标(其中(0,0)位于左下角)。`gl_FragCoord`中也包含了一个`z`分量，它包含了片段真正的深度值。`z`值就是需要与深度缓冲内容多对比的那个值。

>大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要清楚一个片段永远不会是可见的(它在其他物体之后)，就能提前丢弃这个片段。
>
>片段着色器通常开销都是很大的，所以应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。

深度测试默认时禁用的，所以如果要启用深度测试的话，需要用`GL_DEPTH_TEST`选项来启用它。

				glEnable(GL_DEPTH_TEST);

当它启用的时候，如果一个片段通过深度测试的话，OpenGL会在深度缓冲区中储存该片段的`z`值；如果没有通过深度缓冲，则会丢弃该片段。如果启用了深度缓冲，还应该在每个渲染迭代之前使用`GL_DEPTH_BUFFER_BIT`来清除深度缓冲，否则会仍在使用上一次渲染迭代中的写入的深度值:

				glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
				
在某些情况下会需要对所有片段都执行深度测试并丢弃相应的片段，但不希望更新深度缓冲。基本上来说，在使用一个只读的(Read-only)深度缓冲。OpenGL允许禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为`GL_FALSE`就可以了:

				glDepthMask(GL_FALSE);
				
注意这只在深度测试被启用的时候才有效。

1.**深度测试函数**

OpenGL允许修改深度测试中使用的比较运算符。通过这样可以控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲区。可以调用`glDepthFunc`函数来设置比较运算符:

				glDepthFunc(GL_LESS);

这个函数接受下面表格中的比较运算符:

|  函数			|		描述 					|
| ----------	| -------------				|
| GL_ALWAYS	| 永远通过深度测试 				|
| GL_NEVER	| 永远不通过深度测试			|
| GL_LESS		| 在片段深度值小于缓冲的深度值时通过测试  |
| GL_EQUAL	| 在片段深度值等于缓冲区的深度值时通过测试 |
| GL_LEQUAL	| 在片段深度值小于等于缓冲区的深度值时通过测试 |
| GL_GREATER	| 在片段深度值大于缓冲区的深度值时通过测试 |
| GL_NOTEQUAL	| 在片段深度值不等于缓冲区的深度值时通过测试 |
| GL_GEQUAL	| 在片段深度值大于等于缓冲区的深度值时通过测试 |

默认情况下使用的深度函数是`GL_LESS`，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。当深度测试函数的参数值改为`GL_ALWAYS`时，深度测试将会永远通过，所以最后绘制的片段将会总是会渲染在之前绘制片段的上面，即使之前绘制的片段本就应该渲染在最前面。

2.**深度值精度**

深度缓冲区包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的`z`值进行比较。观察空间的`z`值可能是投影平截头体的近平面(Near)和远平面(Far)之间的任何值。需要一种方式来将这些观察空间的`z`值变换到[0,1]范围之内，其中的一种方式就是将它们线性变换到[0,1]范围之间。下面这个(线性)方程将`z`值变换到0.0到1.0之间的深度值:

![线性深度生成方程式](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter4/depthtesting.png)

这里的`near`和`far`值是提供给投影矩阵设置可视平截头体的那个`near`和`far`值，这个方程需要平截头体中的一个`z`值，并将它变换到[0,1]的范围中。`z`值和对应的深度值之间的关系可以在下图中看到:

![线性深度生成z值的图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter4/zdepth.png)

>注意所有的方程都会将非常近的物体的深度值设置为接近0.0的值，而当物体非常接近远平面的时候，它的深度值会非常接近1.0。

然而，在实践中是几乎永远不会使用这样的**线性深度缓冲(Linear Depth Buffer)**的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与`1/z`成正比的。它做的就是在`z`值很小的时候提供非常高的精度，而在`z`值很远的时候提供更少的精度。

由于非线性方程与`1/z`成正比，在1.0和2.0之间的`z`值将会变换至1.0到0.5之间的深度值，这就是一个float提供给一半精度，这在`z`值很小的情况下提供了非常大的精度。在50.0和100.0之间的`z`值将会只占2%的float精度。这样的一个考虑了远近距离的方程是这样的:

![非线性生成z值的方程](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter4/1-zdepth.png)

深度缓冲中的值在屏幕空间中不是线性的(在透视矩阵应用之前在观察空间中是线性的)，深度缓冲中0.5的值并不代表着物体的`z`值是谓语平截头体的中间，这个顶点的`z`值实际上非常接近平面。下图中可看到`z`值和最终的深度缓冲值之间的非线性关系:

![非线性生成z值的图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter4/1-depth-pic.png)

可以看到，深度值很大一部分是有很小的`z`值所决定的，这给了近处的物体很大的深度精度。这个变换`z`值的方程是嵌入在投影矩阵中的，所以当想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。

3.**深度缓冲的可视化**

片段着色器中内建`gl_FragCoord`向量的`z`值包含了那个特定片段的深度值。如果将这个深度值输出为颜色，就可以显示场景中所有片段的深度值。

屏幕空间中的深度值是非线性的，即它在`z`值很小的时候有很高的精度，而`z`值很大的时候有较低的精度。片段的深度值会随着距离迅速增加，所以几乎所有的顶点的深度值都是接近于1.0的。如果小心地靠近物体，可能会最终注意到颜色会渐渐变暗，显示它们的`z`值在逐渐变小。

这很清楚地展示了深度值的非线性性质。近处的物体比起远处的物体对深度值有着更大的影响。只需要移动几厘米就能让颜色从暗完全变白。

然而，也可以让片段非线性的深度值变换为线性的。要实现这个，需要仅仅反转深度值的投影变换。这也就意味着需要首先将深度值从[0,1]范围重新变换到[-1,1]范围的标准化设备坐标(裁剪空间)。接下来需要向投影矩阵那样反转这个非线性方程(方程2)，并将这个反转的方程应用到最终的深度值上。最终的结果就是一个线性的深度值。

4.**深度冲突**

一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断在切换前后顺序，这会绘制导致很奇怪花纹。这个现象叫做**深度冲突(Z-fighting)**，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。

深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显(因为深度缓冲在`Z`值比较大的时候有着更小的精度)。深度冲突不恩感完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突。

5.**防止深度冲突**

第一个也是最重要的技巧是**永远不要把多个腿摆得太靠近，以至于它们的一些三角形会重叠**。通过在两个物体之间设置一个用户无法注意到的偏移值，可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，可以将箱子沿着正`y`轴稍微移动一点。

第二个技巧是**尽可能将近平面设置远一些**。在前面提到了精度在靠近近平面时是非常高的，所以如果将近平面远离观察者，将会对真个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁减掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。

第三个技巧是牺牲一些性能，使用**更高精度的深度缓冲**。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。

模版测试
----------------------------------------------------
当片段着色器处理完一个片段之后，**模版测试(Stencil Test)**会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。模版测试是根据有一缓冲区来进行的，它叫做**模版缓冲(Stencil Buffer)**，可以在渲染的时候更新它来获得一些很有意思的效果。

一个模版缓冲区中，(通常)每个**模版值(Stencil Value)**是8位的。所以每个像素/片段一共能有256种不同的模版值。可以将这些模版值设置为想要的值，然后当某一个片段有某一个模版值的时候，就可以选择丢弃或者是保留这个片段。

>每个窗口库都需要为你配置一个模版缓冲区，GLFW自动做了这件事，所以不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模版库。

模版缓冲的一个简单的例子如下：

![模版缓冲区图示](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter4/stenciltesting.png)

模版缓冲区首先会被清除为0，之后在模版缓冲区中使用1填充了一个空心矩形。场景中的片段将会只在片段的模版值为1的时候会被渲染(其它的都被丢弃了)。

模版缓冲操作允许在渲染片段是将模版缓冲区设定为一个特定的值。通过在渲染时修改模版缓冲区的内容，写入模版缓冲区。在同一个(或者接下来的)渲染迭代中，可以读取这些值，来决定丢弃还是保留某个片段。使用模版缓冲的时候可以尽情发挥，但大体的步骤如下：

* 启用模版缓冲的写入。
* 渲染物体，更新模版缓冲的内容。
* 禁用模版缓冲的写入。
* 渲染(其它)物体，这次根据模版缓冲的内容丢弃特定的片段。

所以，通过使用模版缓冲，可以根据场景中已绘制的其他物体的片段，来决定是否丢弃特定的片段。

可以启用`GL_STENCIL_TEST`来启用模版测试。在这一行代码之后，所有的渲染调用都会以某种方式影响着模版缓冲区。

					glEnable(GL_STENCIL_TEST);

注意，和颜色、深度缓冲一样，也需要在每次迭代之前清除模版缓冲。

					glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

和深度测试的`glDepthMask`函数一样，模版缓冲也有一个类似的函数。`glStencilMask`允许设置一个位掩码(Bitmask)，它会与将要写入缓冲的模版值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出。但如果将它设置为`0x00`，写入缓冲的所有模版值最后都会变成0。这雨还说呢度测试中的`glDepthMask(GL_FALSE)`是等价的。

					glStencilMask(0xFF); // 每一位写入模版缓冲时都保持原样
					glStencilMask(0x00); // 每一位在写入模版缓冲时都会变成0(禁止写入)
					
大部分情况下都只会使用`0x00`或者`0xFF`作为模版掩码(Stencil Mask),但是知道有选项可以设置自定义的位掩码总是好的。

1.**模版函数**

和深度测试一样，对模版缓冲应该应该通过还是失败，以及它应该如何影响模版缓冲，也是有一定控制的。一共有两个函数能够用来配置模版测试: `glStencilFunc`和`glStencilOp`。

`glStencilFunc(GLenum func, CLint ref, GLuint mask)`一共包含三个参数:

* `func`:设置模版测试函数(Stencil Test Function)。这个测试函数将会应用到已存储的模版值上和`glStencilFunc`函数的`ref`值上。可用的选项有:`GL_NEVER`、`GL_LESS`、`GL_LEQUAL`、`GL_GREATER`、`GL_GEQUAL`、`GL_EQUAL`、`GL_NOTEQUAL`和`GL_ALWAYS`。它们的语义和深度缓冲的函数类似。
* `ref`:设置模版测试的参考值(Reference Value)。模版缓冲的内容将会与这个值进行比较。
* `mask`:设置一个掩码，它将会与参考值和储存的模版值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1.

在一开始的那个简单的模版例子中，函数被设置为:

				glStencilFunc(GL_EQUAL, 1, 0xFF);

这告诉OpenGL，只要一个片段的模版值等于(`GL_EQUAL`)参数值1，片段将会通过测试并被绘制，否则会被丢弃。

但是`glStencilFunc`仅仅描述了OpenGL应该对模版缓冲区内容做什么，而不是应该如何更新缓冲区。这就需要`glStencilOp`这个函数。

`glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)`一共包含三个选项，能够设定每个选项应该采取的行为:

* `sfail`:模版测试失败时采取的行为。
* `dpfail`:模版测试通过，但深度测试失败时采取的行为。
* `dppass`:模版测试和深度测试都通过时采取的行为。

每个选项都可以选用以下的其中一个行为:

| 行为 				|		描述			|
| -------------	| -----------------	|
| GL_KEEP			| 保持当前存储的模版值	|
| GL_ZERO			| 将模版值设置为0		|
| GL_REPLACE		| 将模版值设置为`glStencilFunc`函数设置的`ref`值 |
| GL_INCR			| 如果模版值小于最大值则将模版值加1 |
| GL_INCR_WRAP	| 与GL_INCR一样，但如果模版值超过了最大值则归零 |
| GL_DECR			| 如果模版值大于最小值则将模版值减1 |
| GL_DECR_WRAP	| 与GL_DECR一样，但如果模版值小于0则将其设置为最大值 |
| GL_INVERT		| 按位翻转当前的模版缓冲值	|

默认情况下`glStencilOp`是设置为`(GL_KEEP, GL_KEEP, GL_KEEP)`的，所以不论任何测试的结果是如何，模版缓冲区都会保留它的值。默认的行为不会更新模版缓冲，所以如果想写入模版缓冲的话，需要至少对其中一个选项设置不同的值。

所以，通过使用`glStencilFunc`和`glStencilOp`，可以精确地指定更新模版缓冲的时机与行为，也可以指定什么时候让模版缓冲通过，即什么时候片段需要被丢弃。

2.**物体轮廓**

为物体创建轮廓的步骤如下:

* 在绘制(需要添加轮廓的)物体之前，将模版函数设置为`GL_ALWAYS`，每当物体的片段被渲染时，将模版缓冲更新为1。
* 渲染物体
* 禁用模版写入以及以及深度测试
* 将每个物体缩放一点点
* 使用一个不同的片段着色器，输出一个单独的(边框)颜色
* 再次绘制物体，但只在它们片段的模版值不等于1时才绘制
* 再次启用模版写入和深度测试

这个过程将每个物体的片段的模版缓冲设置为1，当想要绘制边框的时候，主要绘制放大版本的物体中模版测试通过的部分，也就是物体的边框的位置。主要使用模版缓冲丢弃了放大版本中属于原物体片段的部分。

3.**适用范围**

这个算法能够在一个模型类中轻松实现。可以在模型类中设置一个`boolean`标记，来设置需不需要绘制边框。除了物体轮廓之外，模版测试还有很多用途，比如在后视镜中绘制纹理，让它能够绘制到镜子形状中，或者使用一个叫做阴影体积(`Shadow Volume`)的模版缓冲技术渲染实时阴影。模版缓冲为丰富OpenGL工具箱又提供了一个很好的工具。

混合
------------------------------------------------------
OpenGL中，**混合(Blending)**通常是实现物体**透明度(Transparency)**的一种技术。透明就是说一个物体(或者其中的一部分)不是纯色(Solid Color)的。它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度组合。这也就是混合这一名字的出处，**混合(Blend)**多种颜色为一种颜色。

**丢弃片段**

在片段着色器中，`GLSL`提供了`discard`命令，一旦被调用，它就会保证片段不会被进一步处理，所以就不会进入颜色缓冲。有了这个命令，就能够在片段着色器中检测一个片段的`alpha`值是否低于某个阀值，如果是的话，则丢弃这个片段，就好像它不存在一样。

**混合**

要想渲染有多个透明度级别的图像，需要启用**混合(Blending)**。

>`glEnable(GL_BLEND);`

启用混合之后，需要告诉`OpenGL`它该如何混合。

`OpenGL`中的混合是通过下面这个方程来实现的:

![混合实现方式](https://github.com/whynotAC/Learn_Opengl/blob/master/Document/chapter4/blending.jpg)

片段着色器运行完成后，并且所有的测试都通过之后，这个**混合方程(Blend Equation)**才会应用到片段颜色输出与当前颜色缓冲中的值上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。

`OpenGL`提供了一个专门的函数`glBlendFunc`。

>`glBlendFunc(GLenum sfactor, GLenum dfactor);`

这个函数接受两个参数，来设置**源**和**目标因子**。`OpenGL`定义了很多个选项，将在下面列出大部分最常用的选项。注意仓鼠颜色向量可以通过`glBlendColor`函数来另外设置。

|		选项		|		值			|
| -------------	| ------------	|
| GL_ZERO			| 因子等于0			|
| GL_ONE			| 因子等于1			|
| GL\_SRC\_COLOR	| 因子等于源颜色向量Csource|
| GL\_ONE\_MINUS\_SRC\_COLOR | 因子等于1 - Csource |
| GL\_DST\_COLOR 	| 因子等于目标颜色向量Cdestination |
| GL\_ONE\_MINUS\_DST\_COLOR | 因子等于1 - Cdestination |
| GL\_SRC\_ALPHA	| 因子等于Csource的alpha分量 |
| GL\_ONE\_MINUS\_SRC\_ALPHA | 因子等于1 - Csource的alpha分量 |
| GL\_DST\_ALPHA	| 因子等于Cdestination的alpha分量 |
| GL\_ONE\_MINUS\_DST\_ALPHA | 因子等于1 - Cdestination的alpha分量 |
| GL\_CONSTANT\_COLOR | 因子等于常数颜色向量Cconstant |
| GL\_ONE\_MINUS\_CONSTANT\_COLOR | 因子等于1 - Cconstant |
| GL\_CONSTANT\_ALPHA | 因子等于Cconstant的alpha分量 |
| GL\_ONE\_MINUS\_CONSTANT\_ALPHA | 因子等于1 - Cconstant的alpha分量 |

为了获得之前两个方形的混合结果，需要使用源颜色向量的`alpha`作为源因子，使用`1 - alpha`作为目标因子。将会产生以下的`glBlendFunc`:

>`glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);`

也可以使用`glBlendFuncSeparate`为`RGB`和`alpha`通道分别设置不同的选项:

>`glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);`

这个函数和之前设置的那样设置了`RGB`分量，但这样只能让最终的`alpha`分量被源颜色向量的`alpha`值所影响到。

`OpenGL`提供了多种灵活性，允许改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，也可以让它们相减。`glBlendEquation(GLenum mode)`允许设置运算符，它提供了三个选项：

* `GL_FUNC_ADD`:默认选项，将两个分量相加: Cresult = Src + Dst.
* `GL_FUNC_SUBTRACT`:将两个分量相减: Cresult = Src - Dst.
* `GL_FUNC_REVERSE_SUBTRACT`:将两个分量相减，但顺序相反: Cresult = Dst - Src.

通常可以省略调用`glBlendEquation`。

**渲染半透明纹理**

每当`OpenGL`渲染一个片段时，它都会将当前片段的颜色和当前颜色缓冲中的片段颜色根据`alpha`值来进行混合。

当透明的窗户和木箱同时存在时，会发生透明窗户绘制不正确的现象。发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃它们。

所以不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，必须先手动将窗户按照最远到最近来排序，在按照顺序渲染。

>PS:对于草这中全透明的物体，可以选择丢弃透明的片段而不是混合它们。

**不要打乱顺序**

要想让混合在多个物体上工作，需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但让仍要保证它们在绘制(排序的)透明物体之前已经绘制完毕。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下:

1. 先绘制所有不透明的物体。
2. 对所有透明的物体排序。
3. 按顺序绘制所有透明的物体。

排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。

在场景中排序物体是一个很困难的技术，很大程度上由场景的类型所决定，更别说它额外需要消耗的处理能力。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有**次序无关透明度(Order Independent Transparaency,OIT)**.