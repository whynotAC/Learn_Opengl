记录有关opengl的知识
==================

渲染过程
--------------

**顶点数据---->顶点着色器---->形状(图元)装配---->几何着色器---->光栅化---->片段着色器---->测试与混合**

图形渲染管线的第一个部分是**顶点着色器(Vertex Shader)**,它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D左边转变为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本操作。

**图元装配(Primitive Assembly)**阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。

图元装配阶段的输出会传递给**几何着色器(Geometry Shader)**。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的(或者是其它的)图元来生成其他形状。

几何着色器的输出会被传入**光栅化阶段**，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行剪切(Clipping)。剪切会丢弃超出你的视图以外所有像素，用来提升效率。

**片段着色器**的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据，这些数据可以被用来计算最终像素的颜色。

在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，叫**Alpha测试和混合(Blending)阶段**。这个阶段检测片段的对应的深度(和模版(Stencil))值，用它们来判断这个像素是其他物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。

通过**顶点穿冲对象(Vertex Buffer Objects,VBO)**管理这个内存，它会在GPU内存(显卡)中存储大量顶点。使用这些缓冲对象的好处是可以一次性的发送大批数据到显卡上，而不是每个顶点发送一次。

**顶点数组对象(Vertex Array Object,VAO)**可以像顶点穿冲对象那样被绑定，任何随后的顶点属性调用都会存储在这个VAO中。

着色器
-----------------------
着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。

**GLSL**

着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中处理所有的输入变量，并将结果输出到输出变量中。

顶点着色器的每个输入变量也叫顶点属性(Vertex Attribute)。能够声明的顶点属性是有上限的，由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，可以通过`glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &)`来查询。

GLSL中有两种容器类型：**向量**和**矩阵**。

|	类型	|	含义	|
| -------	| ------	|
| vecn		| 包含n个float分量的默认向量		|
| bvecn	| 包含n个bool分量的向量			|
| ivecn	| 包含n个int分量的向量				|
| uvecn	| 包含n个unsigned int分量的向量 	|
| dvecn	| 包含n个double分量的向量			|

**输入和输出**

每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了`in`和`out`关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量和洗衣歌着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器上会有些不同。

顶点着色器从顶点数据中直接接受输入。为了定义顶点数据该如何管理，使用`location`这一元数据指定输入变量，这样才可以在CPU上配置顶点属性。顶点着色器还需要为它的输入提供一个额外的`layout`标识，这样才能把它链接到顶点数据。

片段着色器需要一个`vec4`颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。

如果打算从一个着色器向另一个着色器发送数据，必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了(在链接程序对象时完成的。)

纹理
----------------------
纹理是一个2D图片(甚至也有1D和3D的纹理)，它可以用来添加物体的细节。为了能够把纹理映射(Map)到三角形上，需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分进行采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。

纹理坐标在X和Y轴上，范围为0到1之间。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0,0)，也就是纹理图片的左下角，终始于(1,1)，即纹理图片的右上角。

**纹理环绕方式**

纹理坐标的范围通常是从(0,0)到(1,1),那如果把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像，但OpenGL提供更多的选择。

|   环绕方式  			|			描述		|
| ----------			| 		---------		|
| GL_REPEAT			| 对纹理的默认行为，重复纹理图像 |
| GL_MIRRORED_REPEAT| 和GL_REPEAT一样，但每次重复图像是镜像放置的 |
| GL_CLAMP_TO_EDGE	| 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果 |
| GL_CLAMP_TO_BORDER| 超出的坐标为用户指定的边缘颜色 |

**纹理过滤**

纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，只讨论最重要的两种: GL_NEAREST和GL_LINEAR。

GL_NEAREST(临近过滤，Nearest Neighbor Filtering)是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择最接近纹理坐标的那个像素。

GL_LINEAR(线性过滤，(Bi)linear Filtering)它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。

**多级渐远纹理**

原因在于较远的物体拥有与近处物体一样的高的分辨率，由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。OpenGL中采用多级渐远纹理(Mipmap)的概念来解决问题，简单来讲就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的原理很简单：距观察者的距离超过一定的阀值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一个加分之处是它的性能非常好。

OpenGL中有一个glGenerateMipmaps函数，在创建完一个纹理后调用它,OpenGL就会承接下来的所有工作。对于多级纹理之间会产生不真实的生硬边界，因此可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。

|		过滤方式			|		描述		|
| ----------------		| --------		|
| GL_NEAREST_MIPMAP_NEARESST | 使用最邻近的多级渐远纹理来匹配像素大小，并使用临近插值进行纹理采样 |
| GL_LINEAR_MIPMAP_NEAREST  | 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样  |
| GL_NEAREST_MIPMAP_LINEAR | 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用临近插值进行采样 |
| GL_LINEAR_MIPMAP_LINEAR | 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 |

GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)。GLSL内建的texture函数来采样纹理的颜色。

**纹理单元**

能够在一个片段着色器中设置多个纹理，一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元。

纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。

>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL\_TEXTURE0到GL\_TEXTURE15。
>它们都是按顺序定义的，所以也可以通过GL\_TEXTURE0 + 8的方式获得GL\_TEXTURE8，这在当我们需
>要循环一些纹理单元的时候会很有用。

变换
----------------------

**向量**

向量拥有一个方向和大小。

**向量与标量运算**

表量(Scalar)只是一个数字(或者说是仅有一个分量的向量)。当把一个向量加/减/乘/除一个表量，等于把向量的每个分量分别进行该运算。

**向量取反**

对一个向量取反(Negate)会将其方向逆转

**向量加减**

向量的加减法可以被定义为是分量的(component-wise)相加减，即将一个向量中的每一个分量加上/减去另一个向量的对应分量。

**长度**

使用勾股定理来求解出向量的长度，即`||v|| = (x^2 + y^2)的根号`，单位向量的长度为1。向量的标准化即为将向量的各个分量除以向量的长度。

**向量相乘**

向量相乘有两种乘法，一个是点乘(Dot Product)，记作v·k，另一个是叉乘(Cross Product)，记作v X k。

**点乘**

两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。

					`v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ`

通过点乘可以很容易测试两个向量是否平行或者正交。

**叉乘**

叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个相互正交的向量。

**矩阵**

矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素。矩阵的行列数为矩阵的维度。

**矩阵的加法**

矩阵与标量相加减，即矩阵中的每一个元素都加减上相同的表量。

矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，对于矩阵之间的加减法之对于同维度的矩阵才是有定义的。

**矩阵的数乘**

和矩阵与标量的加减一样，矩阵与标量之间的乘法也就是矩阵的每一个元素分别乘以该表量。

**矩阵相乘**

矩阵相乘的限制：

1.只有当左侧矩阵的列数于右侧矩阵的行数相等，两个矩阵才能相乘。
2.矩阵相乘不遵守交换律(Commutative)，也就是说`A⋅B≠B⋅A`。

**矩阵与向量相乘**

向量可以看作是一个N✖️1矩阵，N表示向量分量的个数(也叫N维向量)。向量和矩阵一样都是一个数字序列，但它只有1列。

**单位矩阵**

在OpenGL中，通常使用4✖️4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。单位矩阵(Identity Matrix)。单位矩阵是一个除了对角线以外都是0的N✖️N的矩阵。

>单位矩阵通常是生成其他变换矩阵的起点。

**缩放**

对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。OpenGL通常是在3D空间进行操作的，对于2D的情况可以把z轴缩放1倍，这样z轴的值就不变化了。对于各个坐标值进行不同级别的缩放，这样的操作叫做不均匀(Non-uniform)缩放，因为每个轴的缩放因子(Scaling Factor)都不一样。

**位移**

位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。

>齐次坐标(Homogeneous Coordinates)
>
>向量的w分量也叫齐次坐标。想要从其次向量得到3D向量，可以把x、y、z坐标分别除以w坐标。

**旋转**

>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的:
>
>			弧度转角度：`角度 = 弧度 * (180.0f / PI)`
>			角度转弧度:	`弧度 = 角度 * (PI / 180.0f)`
>
>PI约等于3.14159265359

在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。

**矩阵的组合**

使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个转换组合到一个矩阵中。当矩阵相乘时先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会(消极地)相互影响。
