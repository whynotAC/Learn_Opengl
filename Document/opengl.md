记录有关opengl的知识
==================

渲染过程
--------------

**顶点数据---->顶点着色器---->形状(图元)装配---->几何着色器---->光栅化---->片段着色器---->测试与混合**

图形渲染管线的第一个部分是**顶点着色器(Vertex Shader)**,它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D左边转变为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本操作。

**图元装配(Primitive Assembly)**阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。

图元装配阶段的输出会传递给**几何着色器(Geometry Shader)**。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的(或者是其它的)图元来生成其他形状。

几何着色器的输出会被传入**光栅化阶段**，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行剪切(Clipping)。剪切会丢弃超出你的视图以外所有像素，用来提升效率。

**片段着色器**的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据，这些数据可以被用来计算最终像素的颜色。

在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，叫**Alpha测试和混合(Blending)阶段**。这个阶段检测片段的对应的深度(和模版(Stencil))值，用它们来判断这个像素是其他物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。

通过**顶点穿冲对象(Vertex Buffer Objects,VBO)**管理这个内存，它会在GPU内存(显卡)中存储大量顶点。使用这些缓冲对象的好处是可以一次性的发送大批数据到显卡上，而不是每个顶点发送一次。

**顶点数组对象(Vertex Array Object,VAO)**可以像顶点穿冲对象那样被绑定，任何随后的顶点属性调用都会存储在这个VAO中。

着色器
-----------------------
着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。

**GLSL**

着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中处理所有的输入变量，并将结果输出到输出变量中。

顶点着色器的每个输入变量也叫顶点属性(Vertex Attribute)。能够声明的顶点属性是有上限的，由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，可以通过`glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &)`来查询。

GLSL中有两种容器类型：**向量**和**矩阵**。

|	类型	|	含义	|
| -------	| ------	|
| vecn		| 包含n个float分量的默认向量		|
| bvecn	| 包含n个bool分量的向量			|
| ivecn	| 包含n个int分量的向量				|
| uvecn	| 包含n个unsigned int分量的向量 	|
| dvecn	| 包含n个double分量的向量			|

